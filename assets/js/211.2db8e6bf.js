(window.webpackJsonp=window.webpackJsonp||[]).push([[211],{648:function(a,e,v){"use strict";v.r(e);var t=v(25),_=Object(t.a)({},(function(){var a=this,e=a.$createElement,v=a._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h1",{attrs:{id:"运算符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#运算符"}},[a._v("#")]),a._v(" 运算符")]),a._v(" "),v("h2",{attrs:{id:"算术运算符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#算术运算符"}},[a._v("#")]),a._v(" 算术运算符")]),a._v(" "),v("p",[a._v("运算符是处理数据的基本方法，用来从现有的值得到新的值。JavaScript 提供了多种运算符，覆盖了所有主要的运算。")]),a._v(" "),v("h3",{attrs:{id:"概述"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[a._v("#")]),a._v(" 概述")]),a._v(" "),v("p",[a._v("JavaScript 共提供10个算术运算符，用来完成基本的算术运算。")]),a._v(" "),v("ul",[v("li",[v("strong",[a._v("加法运算符")]),a._v("："),v("code",[a._v("x + y")])]),a._v(" "),v("li",[v("strong",[a._v("减法运算符")]),a._v("： "),v("code",[a._v("x - y")])]),a._v(" "),v("li",[v("strong",[a._v("乘法运算符")]),a._v("： "),v("code",[a._v("x * y")])]),a._v(" "),v("li",[v("strong",[a._v("除法运算符")]),a._v("："),v("code",[a._v("x / y")])]),a._v(" "),v("li",[v("strong",[a._v("指数运算符")]),a._v("："),v("code",[a._v("x ** y")])]),a._v(" "),v("li",[v("strong",[a._v("余数运算符")]),a._v("："),v("code",[a._v("x % y")])]),a._v(" "),v("li",[v("strong",[a._v("自增运算符")]),a._v("："),v("code",[a._v("++x")]),a._v(" 或者 "),v("code",[a._v("x++")])]),a._v(" "),v("li",[v("strong",[a._v("自减运算符")]),a._v("："),v("code",[a._v("--x")]),a._v(" 或者 "),v("code",[a._v("x--")])]),a._v(" "),v("li",[v("strong",[a._v("数值运算符")]),a._v("： "),v("code",[a._v("+x")])]),a._v(" "),v("li",[v("strong",[a._v("负数值运算符")]),a._v("："),v("code",[a._v("-x")])])]),a._v(" "),v("p",[a._v("减法、乘法、除法运算法比较单纯，就是执行相应的数学运算。下面介绍其他几个算术运算符，重点是加法运算符。")]),a._v(" "),v("h3",{attrs:{id:"加法运算符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#加法运算符"}},[a._v("#")]),a._v(" 加法运算符")]),a._v(" "),v("h4",{attrs:{id:"基本规则"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#基本规则"}},[a._v("#")]),a._v(" 基本规则")]),a._v(" "),v("p",[a._v("加法运算符（"),v("code",[a._v("+")]),a._v("）是最常见的运算符，用来求两个数值的和。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("1 + 1 // 2\n")])])]),v("p",[a._v("JavaScript 允许非数值的相加。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("true + true // 2\n1 + true // 2\n")])])]),v("p",[a._v("上面代码中，第一行是两个布尔值相加，第二行是数值与布尔值相加。这两种情况，布尔值都会自动转成数值，然后再相加。")]),a._v(" "),v("p",[a._v("比较特殊的是，如果是两个字符串相加，这时加法运算符会变成连接运算符，返回一个新的字符串，将两个原字符串连接在一起。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("'a' + 'bc' // \"abc\"\n")])])]),v("p",[a._v("如果一个运算子是字符串，另一个运算子是非字符串，这时非字符串会转成字符串，再连接在一起。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("1 + 'a' // \"1a\"\nfalse + 'a' // \"falsea\"\n")])])]),v("p",[a._v("加法运算符是在运行时决定，到底是执行相加，还是执行连接。也就是说，运算子的不同，导致了不同的语法行为，这种现象称为“重载”（overload）。由于加法运算符存在重载，可能执行两种运算，使用的时候必须很小心。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("'3' + 4 + 5 // \"345\"\n3 + 4 + '5' // \"75\"\n")])])]),v("p",[a._v("上面代码中，由于从左到右的运算次序，字符串的位置不同会导致不同的结果。")]),a._v(" "),v("p",[a._v("除了加法运算符，其他算术运算符（比如减法、除法和乘法）都不会发生重载。它们的规则是：所有运算子一律转为数值，再进行相应的数学运算。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("1 - '2' // -1\n1 * '2' // 2\n1 / '2' // 0.5\n")])])]),v("p",[a._v("上面代码中，减法、除法和乘法运算符，都是将字符串自动转为数值，然后再运算。")]),a._v(" "),v("h4",{attrs:{id:"对象的相加"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#对象的相加"}},[a._v("#")]),a._v(" 对象的相加")]),a._v(" "),v("p",[a._v("如果运算子是对象，必须先转成原始类型的值，然后再相加。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v('var obj = { p: 1 };\nobj + 2 // "[object Object]2"\n')])])]),v("p",[a._v("上面代码中，对象"),v("code",[a._v("obj")]),a._v("转成原始类型的值是"),v("code",[a._v("[object Object]")]),a._v("，再加"),v("code",[a._v("2")]),a._v("就得到了上面的结果。")]),a._v(" "),v("p",[a._v("对象转成原始类型的值，规则如下。")]),a._v(" "),v("p",[a._v("首先，自动调用对象的"),v("code",[a._v("valueOf")]),a._v("方法。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var obj = { p: 1 };\nobj.valueOf() // { p: 1 }\n")])])]),v("p",[a._v("一般来说，对象的"),v("code",[a._v("valueOf")]),a._v("方法总是返回对象自身，这时再自动调用对象的"),v("code",[a._v("toString")]),a._v("方法，将其转为字符串。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v('var obj = { p: 1 };\nobj.valueOf().toString() // "[object Object]"\n')])])]),v("p",[a._v("对象的"),v("code",[a._v("toString")]),a._v("方法默认返回"),v("code",[a._v("[object Object]")]),a._v("，所以就得到了最前面那个例子的结果。")]),a._v(" "),v("p",[a._v("知道了这个规则以后，就可以自己定义"),v("code",[a._v("valueOf")]),a._v("方法或"),v("code",[a._v("toString")]),a._v("方法，得到想要的结果。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var obj = {\n  valueOf: function () {\n    return 1;\n  }\n};\n\nobj + 2 // 3\n")])])]),v("p",[a._v("上面代码中，我们定义"),v("code",[a._v("obj")]),a._v("对象的"),v("code",[a._v("valueOf")]),a._v("方法返回"),v("code",[a._v("1")]),a._v("，于是"),v("code",[a._v("obj + 2")]),a._v("就得到了"),v("code",[a._v("3")]),a._v("。这个例子中，由于"),v("code",[a._v("valueOf")]),a._v("方法直接返回一个原始类型的值，所以不再调用"),v("code",[a._v("toString")]),a._v("方法。")]),a._v(" "),v("p",[a._v("下面是自定义"),v("code",[a._v("toString")]),a._v("方法的例子。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var obj = {\n  toString: function () {\n    return 'hello';\n  }\n};\n\nobj + 2 // \"hello2\"\n")])])]),v("p",[a._v("上面代码中，对象"),v("code",[a._v("obj")]),a._v("的"),v("code",[a._v("toString")]),a._v("方法返回字符串"),v("code",[a._v("hello")]),a._v("。前面说过，只要有一个运算子是字符串，加法运算符就变成连接运算符，返回连接后的字符串。")]),a._v(" "),v("p",[a._v("这里有一个特例，如果运算子是一个"),v("code",[a._v("Date")]),a._v("对象的实例，那么会优先执行"),v("code",[a._v("toString")]),a._v("方法。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var obj = new Date();\nobj.valueOf = function () { return 1 };\nobj.toString = function () { return 'hello' };\n\nobj + 2 // \"hello2\"\n")])])]),v("p",[a._v("上面代码中，对象"),v("code",[a._v("obj")]),a._v("是一个"),v("code",[a._v("Date")]),a._v("对象的实例，并且自定义了"),v("code",[a._v("valueOf")]),a._v("方法和"),v("code",[a._v("toString")]),a._v("方法，结果"),v("code",[a._v("toString")]),a._v("方法优先执行。")]),a._v(" "),v("h3",{attrs:{id:"余数运算符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#余数运算符"}},[a._v("#")]),a._v(" 余数运算符")]),a._v(" "),v("p",[a._v("余数运算符（"),v("code",[a._v("%")]),a._v("）返回前一个运算子被后一个运算子除，所得的余数。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("12 % 5 // 2\n")])])]),v("p",[a._v("需要注意的是，运算结果的正负号由第一个运算子的正负号决定。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("-1 % 2 // -1\n1 % -2 // 1\n")])])]),v("p",[a._v("所以，为了得到负数的正确余数值，可以先使用绝对值函数。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("// 错误的写法\nfunction isOdd(n) {\n  return n % 2 === 1;\n}\nisOdd(-5) // false\nisOdd(-4) // false\n\n// 正确的写法\nfunction isOdd(n) {\n  return Math.abs(n % 2) === 1;\n}\nisOdd(-5) // true\nisOdd(-4) // false\n")])])]),v("p",[a._v("余数运算符还可以用于浮点数的运算。但是，由于浮点数不是精确的值，无法得到完全准确的结果。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("6.5 % 2.1\n// 0.19999999999999973\n")])])]),v("h3",{attrs:{id:"自增和自减运算符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#自增和自减运算符"}},[a._v("#")]),a._v(" 自增和自减运算符")]),a._v(" "),v("p",[a._v("自增和自减运算符，是一元运算符，只需要一个运算子。它们的作用是将运算子首先转为数值，然后加上1或者减去1。它们会修改原始变量。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var x = 1;\n++x // 2\nx // 2\n\n--x // 1\nx // 1\n")])])]),v("p",[a._v("上面代码的变量"),v("code",[a._v("x")]),a._v("自增后，返回"),v("code",[a._v("2")]),a._v("，再进行自减，返回"),v("code",[a._v("1")]),a._v("。这两种情况都会使得，原始变量"),v("code",[a._v("x")]),a._v("的值发生改变。")]),a._v(" "),v("p",[a._v("运算之后，变量的值发生变化，这种效应叫做运算的副作用（side effect）。自增和自减运算符是仅有的两个具有副作用的运算符，其他运算符都不会改变变量的值。")]),a._v(" "),v("p",[a._v("自增和自减运算符有一个需要注意的地方，就是放在变量之后，会先返回变量操作前的值，再进行自增/自减操作；放在变量之前，会先进行自增/自减操作，再返回变量操作后的值。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var x = 1;\nvar y = 1;\n\nx++ // 1\n++y // 2\n")])])]),v("p",[a._v("上面代码中，"),v("code",[a._v("x")]),a._v("是先返回当前值，然后自增，所以得到"),v("code",[a._v("1")]),a._v("；"),v("code",[a._v("y")]),a._v("是先自增，然后返回新的值，所以得到"),v("code",[a._v("2")]),a._v("。")]),a._v(" "),v("h3",{attrs:{id:"数值运算符-负数值运算符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数值运算符-负数值运算符"}},[a._v("#")]),a._v(" 数值运算符，负数值运算符")]),a._v(" "),v("p",[a._v("数值运算符（"),v("code",[a._v("+")]),a._v("）同样使用加号，但它是一元运算符（只需要一个操作数），而加法运算符是二元运算符（需要两个操作数）。")]),a._v(" "),v("p",[a._v("数值运算符的作用在于可以将任何值转为数值（与"),v("code",[a._v("Number")]),a._v("函数的作用相同）。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("+true // 1\n+[] // 0\n+{} // NaN\n")])])]),v("p",[a._v("上面代码表示，非数值经过数值运算符以后，都变成了数值（最后一行"),v("code",[a._v("NaN")]),a._v("也是数值）。具体的类型转换规则，参见《数据类型转换》一章。")]),a._v(" "),v("p",[a._v("负数值运算符（"),v("code",[a._v("-")]),a._v("），也同样具有将一个值转为数值的功能，只不过得到的值正负相反。连用两个负数值运算符，等同于数值运算符。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var x = 1;\n-x // -1\n-(-x) // 1\n")])])]),v("p",[a._v("上面代码最后一行的圆括号不可少，否则会变成自减运算符。")]),a._v(" "),v("p",[a._v("数值运算符号和负数值运算符，都会返回一个新的值，而不会改变原始变量的值。")]),a._v(" "),v("h3",{attrs:{id:"指数运算符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#指数运算符"}},[a._v("#")]),a._v(" 指数运算符")]),a._v(" "),v("p",[a._v("指数运算符（"),v("code",[a._v("**")]),a._v("）完成指数运算，前一个运算子是底数，后一个运算子是指数。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("2 ** 4 // 16\n")])])]),v("p",[a._v("注意，指数运算符是右结合，而不是左结合。即多个指数运算符连用时，先进行最右边的计算。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("// 相当于 2 ** (3 ** 2)\n2 ** 3 ** 2\n// 512\n")])])]),v("p",[a._v("上面代码中，由于指数运算符是右结合，所以先计算第二个指数运算符，而不是第一个。")]),a._v(" "),v("h3",{attrs:{id:"赋值运算符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#赋值运算符"}},[a._v("#")]),a._v(" 赋值运算符")]),a._v(" "),v("p",[a._v("赋值运算符（Assignment Operators）用于给变量赋值。")]),a._v(" "),v("p",[a._v("最常见的赋值运算符，当然就是等号（"),v("code",[a._v("=")]),a._v("）。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("// 将 1 赋值给变量 x\nvar x = 1;\n\n// 将变量 y 的值赋值给变量 x\nvar x = y;\n")])])]),v("p",[a._v("赋值运算符还可以与其他运算符结合，形成变体。下面是与算术运算符的结合。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("// 等同于 x = x + y\nx += y\n\n// 等同于 x = x - y\nx -= y\n\n// 等同于 x = x * y\nx *= y\n\n// 等同于 x = x / y\nx /= y\n\n// 等同于 x = x % y\nx %= y\n\n// 等同于 x = x ** y\nx **= y\n")])])]),v("p",[a._v("下面是与位运算符的结合（关于位运算符，请见后文的介绍）。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("// 等同于 x = x >> y\nx >>= y\n\n// 等同于 x = x << y\nx <<= y\n\n// 等同于 x = x >>> y\nx >>>= y\n\n// 等同于 x = x & y\nx &= y\n\n// 等同于 x = x | y\nx |= y\n\n// 等同于 x = x ^ y\nx ^= y\n")])])]),v("p",[a._v("这些复合的赋值运算符，都是先进行指定运算，然后将得到值返回给左边的变量。")]),a._v(" "),v("h2",{attrs:{id:"比较运算符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#比较运算符"}},[a._v("#")]),a._v(" 比较运算符")]),a._v(" "),v("h3",{attrs:{id:"概述-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#概述-2"}},[a._v("#")]),a._v(" 概述")]),a._v(" "),v("p",[a._v("比较运算符用于比较两个值的大小，然后返回一个布尔值，表示是否满足指定的条件。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("2 > 1 // true\n")])])]),v("p",[a._v("上面代码比较"),v("code",[a._v("2")]),a._v("是否大于"),v("code",[a._v("1")]),a._v("，返回"),v("code",[a._v("true")]),a._v("。")]),a._v(" "),v("blockquote",[v("p",[a._v("注意，比较运算符可以比较各种类型的值，不仅仅是数值。")])]),a._v(" "),v("p",[a._v("JavaScript 一共提供了8个比较运算符。")]),a._v(" "),v("ul",[v("li",[v("code",[a._v(">")]),a._v(" 大于运算符")]),a._v(" "),v("li",[v("code",[a._v("<")]),a._v(" 小于运算符")]),a._v(" "),v("li",[v("code",[a._v("<=")]),a._v(" 小于或等于运算符")]),a._v(" "),v("li",[v("code",[a._v(">=")]),a._v(" 大于或等于运算符")]),a._v(" "),v("li",[v("code",[a._v("==")]),a._v(" 相等运算符")]),a._v(" "),v("li",[v("code",[a._v("===")]),a._v(" 严格相等运算符")]),a._v(" "),v("li",[v("code",[a._v("!=")]),a._v(" 不相等运算符")]),a._v(" "),v("li",[v("code",[a._v("!==")]),a._v(" 严格不相等运算符")])]),a._v(" "),v("p",[a._v("这八个比较运算符分成两类：相等比较和非相等比较。两者的规则是不一样的，对于非相等的比较，算法是先看两个运算子是否都是字符串，如果是的，就按照字典顺序比较（实际上是比较 Unicode 码点）；否则，将两个运算子都转成数值，再比较数值的大小。")]),a._v(" "),v("h3",{attrs:{id:"非相等运算符-字符串的比较"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#非相等运算符-字符串的比较"}},[a._v("#")]),a._v(" 非相等运算符：字符串的比较")]),a._v(" "),v("p",[a._v("字符串按照字典顺序进行比较。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("'cat' > 'dog' // false\n'cat' > 'catalog' // false\n")])])]),v("p",[a._v("JavaScript 引擎内部首先比较首字符的 Unicode 码点。如果相等，再比较第二个字符的 Unicode 码点，以此类推。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("'cat' > 'Cat' // true'\n")])])]),v("p",[a._v("上面代码中，小写的"),v("code",[a._v("c")]),a._v("的 Unicode 码点（"),v("code",[a._v("99")]),a._v("）大于大写的"),v("code",[a._v("C")]),a._v("的 Unicode 码点（"),v("code",[a._v("67")]),a._v("），所以返回"),v("code",[a._v("true")]),a._v("。")]),a._v(" "),v("p",[a._v("由于所有字符都有 Unicode 码点，因此汉字也可以比较。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("'大' > '小' // false\n")])])]),v("p",[a._v("上面代码中，“大”的 Unicode 码点是22823，“小”是23567，因此返回"),v("code",[a._v("false")]),a._v("。")]),a._v(" "),v("h3",{attrs:{id:"非相等运算符-非字符串的比较"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#非相等运算符-非字符串的比较"}},[a._v("#")]),a._v(" 非相等运算符：非字符串的比较")]),a._v(" "),v("p",[a._v("如果两个运算子之中，至少有一个不是字符串，需要分成以下两种情况。")]),a._v(" "),v("p",[v("strong",[a._v("（1）原始类型值")])]),a._v(" "),v("p",[a._v("如果两个运算子都是原始类型的值，则是先转成数值再比较。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("5 > '4' // true\n// 等同于 5 > Number('4')\n// 即 5 > 4\n\ntrue > false // true\n// 等同于 Number(true) > Number(false)\n// 即 1 > 0\n\n2 > true // true\n// 等同于 2 > Number(true)\n// 即 2 > 1\n")])])]),v("p",[a._v("上面代码中，字符串和布尔值都会先转成数值，再进行比较。")]),a._v(" "),v("p",[a._v("这里需要注意与"),v("code",[a._v("NaN")]),a._v("的比较。任何值（包括"),v("code",[a._v("NaN")]),a._v("本身）与"),v("code",[a._v("NaN")]),a._v("使用非相等运算符进行比较，返回的都是"),v("code",[a._v("false")]),a._v("。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("1 > NaN // false\n1 <= NaN // false\n'1' > NaN // false\n'1' <= NaN // false\nNaN > NaN // false\nNaN <= NaN // false\n")])])]),v("p",[v("strong",[a._v("（2）对象")])]),a._v(" "),v("p",[a._v("如果运算子是对象，会转为原始类型的值，再进行比较。")]),a._v(" "),v("p",[a._v("对象转换成原始类型的值，算法是先调用"),v("code",[a._v("valueOf")]),a._v("方法；如果返回的还是对象，再接着调用"),v("code",[a._v("toString")]),a._v("方法，详细解释参见《数据类型的转换》一章。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var x = [2];\nx > '11' // true\n// 等同于 [2].valueOf().toString() > '11'\n// 即 '2' > '11'\n\nx.valueOf = function () { return '1' };\nx > '11' // false\n// 等同于 [2].valueOf() > '11'\n// 即 '1' > '11'\n")])])]),v("p",[a._v("两个对象之间的比较也是如此。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("[2] > [1] // true\n// 等同于 [2].valueOf().toString() > [1].valueOf().toString()\n// 即 '2' > '1'\n\n[2] > [11] // true\n// 等同于 [2].valueOf().toString() > [11].valueOf().toString()\n// 即 '2' > '11'\n\n{ x: 2 } >= { x: 1 } // true\n// 等同于 { x: 2 }.valueOf().toString() >= { x: 1 }.valueOf().toString()\n// 即 '[object Object]' >= '[object Object]'\n")])])]),v("h3",{attrs:{id:"严格相等运算符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#严格相等运算符"}},[a._v("#")]),a._v(" 严格相等运算符")]),a._v(" "),v("p",[a._v("JavaScript 提供两种相等运算符："),v("code",[a._v("==")]),a._v("和"),v("code",[a._v("===")]),a._v("。")]),a._v(" "),v("p",[a._v("简单说，它们的区别是相等运算符（"),v("code",[a._v("==")]),a._v("）比较两个值是否相等，严格相等运算符（"),v("code",[a._v("===")]),a._v("）比较它们是否为“同一个值”。如果两个值不是同一类型，严格相等运算符（"),v("code",[a._v("===")]),a._v("）直接返回"),v("code",[a._v("false")]),a._v("，而相等运算符（"),v("code",[a._v("==")]),a._v("）会将它们转换成同一个类型，再用严格相等运算符进行比较。")]),a._v(" "),v("p",[a._v("本节介绍严格相等运算符的算法。")]),a._v(" "),v("p",[v("strong",[a._v("（1）不同类型的值")])]),a._v(" "),v("p",[a._v("如果两个值的类型不同，直接返回"),v("code",[a._v("false")]),a._v("。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v('1 === "1" // false\ntrue === "true" // false\n')])])]),v("p",[a._v("上面代码比较数值的"),v("code",[a._v("1")]),a._v("与字符串的“1”、布尔值的"),v("code",[a._v("true")]),a._v("与字符串"),v("code",[a._v('"true"')]),a._v("，因为类型不同，结果都是"),v("code",[a._v("false")]),a._v("。")]),a._v(" "),v("p",[v("strong",[a._v("（2）同一类的原始类型值")])]),a._v(" "),v("p",[a._v("同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回"),v("code",[a._v("true")]),a._v("，值不同就返回"),v("code",[a._v("false")]),a._v("。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("1 === 0x1 // true\n")])])]),v("p",[a._v("上面代码比较十进制的"),v("code",[a._v("1")]),a._v("与十六进制的"),v("code",[a._v("1")]),a._v("，因为类型和值都相同，返回"),v("code",[a._v("true")]),a._v("。")]),a._v(" "),v("p",[a._v("需要注意的是，"),v("code",[a._v("NaN")]),a._v("与任何值都不相等（包括自身）。另外，正"),v("code",[a._v("0")]),a._v("等于负"),v("code",[a._v("0")]),a._v("。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("NaN === NaN  // false\n+0 === -0 // true\n")])])]),v("p",[v("strong",[a._v("（3）复合类型值")])]),a._v(" "),v("p",[a._v("两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个地址。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("{} === {} // false\n[] === [] // false\n(function () {} === function () {}) // false\n")])])]),v("p",[a._v("上面代码分别比较两个空对象、两个空数组、两个空函数，结果都是不相等。原因是对于复合类型的值，严格相等运算比较的是，它们是否引用同一个内存地址，而运算符两边的空对象、空数组、空函数的值，都存放在不同的内存地址，结果当然是"),v("code",[a._v("false")]),a._v("。")]),a._v(" "),v("p",[a._v("如果两个变量引用同一个对象，则它们相等。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var v1 = {};\nvar v2 = v1;\nv1 === v2 // true\n")])])]),v("p",[a._v("注意，对于两个对象的比较，严格相等运算符比较的是地址，而大于或小于运算符比较的是值。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var obj1 = {};\nvar obj2 = {};\n\nobj1 > obj2 // false\nobj1 < obj2 // false\nobj1 === obj2 // false\n")])])]),v("p",[a._v("上面的三个比较，前两个比较的是值，最后一个比较的是地址，所以都返回"),v("code",[a._v("false")]),a._v("。")]),a._v(" "),v("p",[v("strong",[a._v("（4）undefined 和 null")])]),a._v(" "),v("p",[v("code",[a._v("undefined")]),a._v("和"),v("code",[a._v("null")]),a._v("与自身严格相等。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("undefined === undefined // true\nnull === null // true\n")])])]),v("p",[a._v("由于变量声明后默认值是"),v("code",[a._v("undefined")]),a._v("，因此两个只声明未赋值的变量是相等的。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var v1;\nvar v2;\nv1 === v2 // true\n")])])]),v("h3",{attrs:{id:"严格不相等运算符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#严格不相等运算符"}},[a._v("#")]),a._v(" 严格不相等运算符")]),a._v(" "),v("p",[a._v("严格相等运算符有一个对应的“严格不相等运算符”（"),v("code",[a._v("!==")]),a._v("），它的算法就是先求严格相等运算符的结果，然后返回相反值。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("1 !== '1' // true\n// 等同于\n!(1 === '1')\n")])])]),v("p",[a._v("上面代码中，感叹号"),v("code",[a._v("!")]),a._v("是求出后面表达式的相反值。")]),a._v(" "),v("h3",{attrs:{id:"相等运算符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#相等运算符"}},[a._v("#")]),a._v(" 相等运算符")]),a._v(" "),v("p",[a._v("相等运算符用来比较相同类型的数据时，与严格相等运算符完全一样。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("1 == 1.0\n// 等同于\n1 === 1.0\n")])])]),v("p",[a._v("比较不同类型的数据时，相等运算符会先将数据进行类型转换，然后再用严格相等运算符比较。下面分成几种情况，讨论不同类型的值互相比较的规则。")]),a._v(" "),v("p",[v("strong",[a._v("（1）原始类型值")])]),a._v(" "),v("p",[a._v("原始类型的值会转换成数值再进行比较。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("1 == true // true\n// 等同于 1 === Number(true)\n\n0 == false // true\n// 等同于 0 === Number(false)\n\n2 == true // false\n// 等同于 2 === Number(true)\n\n2 == false // false\n// 等同于 2 === Number(false)\n\n'true' == true // false\n// 等同于 Number('true') === Number(true)\n// 等同于 NaN === 1\n\n'' == 0 // true\n// 等同于 Number('') === 0\n// 等同于 0 === 0\n\n'' == false  // true\n// 等同于 Number('') === Number(false)\n// 等同于 0 === 0\n\n'1' == true  // true\n// 等同于 Number('1') === Number(true)\n// 等同于 1 === 1\n\n'\\n  123  \\t' == 123 // true\n// 因为字符串转为数字时，省略前置和后置的空格\n")])])]),v("p",[a._v("上面代码将字符串和布尔值都转为数值，然后再进行比较。具体的字符串与布尔值的类型转换规则，参见《数据类型转换》一章。")]),a._v(" "),v("p",[v("strong",[a._v("（2）对象与原始类型值比较")])]),a._v(" "),v("p",[a._v("对象（这里指广义的对象，包括数组和函数）与原始类型的值比较时，对象转换成原始类型的值，再进行比较。")]),a._v(" "),v("p",[a._v("具体来说，先调用对象的"),v("code",[a._v("valueOf()")]),a._v("方法，如果得到原始类型的值，就按照上一小节的规则，互相比较；如果得到的还是对象，则再调用"),v("code",[a._v("toString()")]),a._v("方法，得到字符串形式，再进行比较。")]),a._v(" "),v("p",[a._v("下面是数组与原始类型值比较的例子。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("// 数组与数值的比较\n[1] == 1 // true\n\n// 数组与字符串的比较\n[1] == '1' // true\n[1, 2] == '1,2' // true\n\n// 对象与布尔值的比较\n[1] == true // true\n[2] == true // false\n")])])]),v("p",[a._v("上面例子中，JavaScript 引擎会先对数组"),v("code",[a._v("[1]")]),a._v("调用数组的"),v("code",[a._v("valueOf()")]),a._v("方法，由于返回的还是一个数组，所以会接着调用数组的"),v("code",[a._v("toString()")]),a._v("方法，得到字符串形式，再按照上一小节的规则进行比较。")]),a._v(" "),v("p",[a._v("下面是一个更直接的例子。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("const obj = {\n  valueOf: function () {\n    console.log('执行 valueOf()');\n    return obj;\n  },\n  toString: function () {\n    console.log('执行 toString()');\n    return 'foo';\n  }\n};\n\nobj == 'foo'\n// 执行 valueOf()\n// 执行 toString()\n// true\n")])])]),v("p",[a._v("上面例子中，"),v("code",[a._v("obj")]),a._v("是一个自定义了"),v("code",[a._v("valueOf()")]),a._v("和"),v("code",[a._v("toString()")]),a._v("方法的对象。这个对象与字符串"),v("code",[a._v("'foo'")]),a._v("进行比较时，会依次调用"),v("code",[a._v("valueOf()")]),a._v("和"),v("code",[a._v("toString()")]),a._v("方法，最后返回"),v("code",[a._v("'foo'")]),a._v("，所以比较结果是"),v("code",[a._v("true")]),a._v("。")]),a._v(" "),v("p",[v("strong",[a._v("（3）undefined 和 null")])]),a._v(" "),v("p",[v("code",[a._v("undefined")]),a._v("和"),v("code",[a._v("null")]),a._v("只有与自身比较，或者互相比较时，才会返回"),v("code",[a._v("true")]),a._v("；与其他类型的值比较时，结果都为"),v("code",[a._v("false")]),a._v("。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("undefined == undefined // true\nnull == null // true\nundefined == null // true\n\nfalse == null // false\nfalse == undefined // false\n\n0 == null // false\n0 == undefined // false\n")])])]),v("p",[v("strong",[a._v("（4）相等运算符的缺点")])]),a._v(" "),v("p",[a._v("相等运算符隐藏的类型转换，会带来一些违反直觉的结果。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("0 == ''             // true\n0 == '0'            // true\n\n2 == true           // false\n2 == false          // false\n\nfalse == 'false'    // false\nfalse == '0'        // true\n\nfalse == undefined  // false\nfalse == null       // false\nnull == undefined   // true\n\n' \\t\\r\\n ' == 0     // true\n")])])]),v("p",[a._v("上面这些表达式都不同于直觉，很容易出错。因此建议不要使用相等运算符（"),v("code",[a._v("==")]),a._v("），最好只使用严格相等运算符（"),v("code",[a._v("===")]),a._v("）。")]),a._v(" "),v("h3",{attrs:{id:"不相等运算符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#不相等运算符"}},[a._v("#")]),a._v(" 不相等运算符")]),a._v(" "),v("p",[a._v("相等运算符有一个对应的“不相等运算符”（"),v("code",[a._v("!=")]),a._v("），它的算法就是先求相等运算符的结果，然后返回相反值。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("1 != '1' // false\n\n// 等同于\n!(1 == '1')\n")])])]),v("h2",{attrs:{id:"布尔运算符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#布尔运算符"}},[a._v("#")]),a._v(" 布尔运算符")]),a._v(" "),v("h3",{attrs:{id:"概述-3"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#概述-3"}},[a._v("#")]),a._v(" 概述")]),a._v(" "),v("p",[a._v("布尔运算符用于将表达式转为布尔值，一共包含四个运算符。")]),a._v(" "),v("ul",[v("li",[a._v("取反运算符："),v("code",[a._v("!")])]),a._v(" "),v("li",[a._v("且运算符："),v("code",[a._v("&&")])]),a._v(" "),v("li",[a._v("或运算符："),v("code",[a._v("||")])]),a._v(" "),v("li",[a._v("三元运算符："),v("code",[a._v("?:")])])]),a._v(" "),v("h3",{attrs:{id:"取反运算符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#取反运算符"}},[a._v("#")]),a._v(" 取反运算符（!）")]),a._v(" "),v("p",[a._v("取反运算符是一个感叹号，用于将布尔值变为相反值，即"),v("code",[a._v("true")]),a._v("变成"),v("code",[a._v("false")]),a._v("，"),v("code",[a._v("false")]),a._v("变成"),v("code",[a._v("true")]),a._v("。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("!true // false\n!false // true\n")])])]),v("p",[a._v("对于非布尔值，取反运算符会将其转为布尔值。可以这样记忆，以下六个值取反后为"),v("code",[a._v("true")]),a._v("，其他值都为"),v("code",[a._v("false")]),a._v("。")]),a._v(" "),v("ul",[v("li",[v("code",[a._v("undefined")])]),a._v(" "),v("li",[v("code",[a._v("null")])]),a._v(" "),v("li",[v("code",[a._v("false")])]),a._v(" "),v("li",[v("code",[a._v("0")])]),a._v(" "),v("li",[v("code",[a._v("NaN")])]),a._v(" "),v("li",[a._v("空字符串（"),v("code",[a._v("''")]),a._v("）")])]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("!undefined // true\n!null // true\n!0 // true\n!NaN // true\n!\"\" // true\n\n!54 // false\n!'hello' // false\n![] // false\n!{} // false\n")])])]),v("p",[a._v("上面代码中，不管什么类型的值，经过取反运算后，都变成了布尔值。")]),a._v(" "),v("p",[a._v("如果对一个值连续做两次取反运算，等于将其转为对应的布尔值，与"),v("code",[a._v("Boolean")]),a._v("函数的作用相同。这是一种常用的类型转换的写法。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("!!x\n// 等同于\nBoolean(x)\n")])])]),v("p",[a._v("上面代码中，不管"),v("code",[a._v("x")]),a._v("是什么类型的值，经过两次取反运算后，变成了与"),v("code",[a._v("Boolean")]),a._v("函数结果相同的布尔值。所以，两次取反就是将一个值转为布尔值的简便写法。")]),a._v(" "),v("h3",{attrs:{id:"且运算符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#且运算符"}},[a._v("#")]),a._v(" 且运算符（&&）")]),a._v(" "),v("p",[a._v("且运算符（"),v("code",[a._v("&&")]),a._v("）往往用于多个表达式的求值。")]),a._v(" "),v("p",[a._v("它的运算规则是：如果第一个运算子的布尔值为"),v("code",[a._v("true")]),a._v("，则返回第二个运算子的值（注意是值，不是布尔值）；如果第一个运算子的布尔值为"),v("code",[a._v("false")]),a._v("，则直接返回第一个运算子的值，且不再对第二个运算子求值。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("'t' && '' // \"\"\n't' && 'f' // \"f\"\n't' && (1 + 2) // 3\n'' && 'f' // \"\"\n'' && '' // \"\"\n\nvar x = 1;\n(1 - 1) && ( x += 1) // 0\nx // 1\n")])])]),v("p",[a._v("上面代码的最后一个例子，由于且运算符的第一个运算子的布尔值为"),v("code",[a._v("false")]),a._v("，则直接返回它的值"),v("code",[a._v("0")]),a._v("，而不再对第二个运算子求值，所以变量"),v("code",[a._v("x")]),a._v("的值没变。")]),a._v(" "),v("p",[a._v("这种跳过第二个运算子的机制，被称为“短路”。有些程序员喜欢用它取代"),v("code",[a._v("if")]),a._v("结构，比如下面是一段"),v("code",[a._v("if")]),a._v("结构的代码，就可以用且运算符改写。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("if (i) {\n  doSomething();\n}\n\n// 等价于\n\ni && doSomething();\n")])])]),v("p",[a._v("上面代码的两种写法是等价的，但是后一种不容易看出目的，也不容易除错，建议谨慎使用。")]),a._v(" "),v("p",[a._v("且运算符可以多个连用，这时返回第一个布尔值为"),v("code",[a._v("false")]),a._v("的表达式的值。如果所有表达式的布尔值都为"),v("code",[a._v("true")]),a._v("，则返回最后一个表达式的值。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("true && 'foo' && '' && 4 && 'foo' && true\n// ''\n\n1 && 2 && 3\n// 3\n")])])]),v("p",[a._v("上面代码中，例一里面，第一个布尔值为"),v("code",[a._v("false")]),a._v("的表达式为第三个表达式，所以得到一个空字符串。例二里面，所有表达式的布尔值都是"),v("code",[a._v("true")]),a._v("，所以返回最后一个表达式的值"),v("code",[a._v("3")]),a._v("。")]),a._v(" "),v("h3",{attrs:{id:"或运算符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#或运算符"}},[a._v("#")]),a._v(" 或运算符（||）")]),a._v(" "),v("p",[a._v("或运算符（"),v("code",[a._v("||")]),a._v("）也用于多个表达式的求值。它的运算规则是：如果第一个运算子的布尔值为"),v("code",[a._v("true")]),a._v("，则返回第一个运算子的值，且不再对第二个运算子求值；如果第一个运算子的布尔值为"),v("code",[a._v("false")]),a._v("，则返回第二个运算子的值。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("'t' || '' // \"t\"\n't' || 'f' // \"t\"\n'' || 'f' // \"f\"\n'' || '' // \"\"\n")])])]),v("p",[a._v("短路规则对这个运算符也适用。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var x = 1;\ntrue || (x = 2) // true\nx // 1\n")])])]),v("p",[a._v("上面代码中，或运算符的第一个运算子为"),v("code",[a._v("true")]),a._v("，所以直接返回"),v("code",[a._v("true")]),a._v("，不再运行第二个运算子。所以，"),v("code",[a._v("x")]),a._v("的值没有改变。这种只通过第一个表达式的值，控制是否运行第二个表达式的机制，就称为“短路”（short-cut）。")]),a._v(" "),v("p",[a._v("或运算符可以多个连用，这时返回第一个布尔值为"),v("code",[a._v("true")]),a._v("的表达式的值。如果所有表达式都为"),v("code",[a._v("false")]),a._v("，则返回最后一个表达式的值。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("false || 0 || '' || 4 || 'foo' || true\n// 4\n\nfalse || 0 || ''\n// ''\n")])])]),v("p",[a._v("上面代码中，例一里面，第一个布尔值为"),v("code",[a._v("true")]),a._v("的表达式是第四个表达式，所以得到数值4。例二里面，所有表达式的布尔值都为"),v("code",[a._v("false")]),a._v("，所以返回最后一个表达式的值。")]),a._v(" "),v("p",[a._v("或运算符常用于为一个变量设置默认值。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("function saveText(text) {\n  text = text || '';\n  // ...\n}\n\n// 或者写成\nsaveText(this.text || '')\n")])])]),v("p",[a._v("上面代码表示，如果函数调用时，没有提供参数，则该参数默认设置为空字符串。")]),a._v(" "),v("h3",{attrs:{id:"三元条件运算符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#三元条件运算符"}},[a._v("#")]),a._v(" 三元条件运算符（?:）")]),a._v(" "),v("p",[a._v("三元条件运算符由问号（?）和冒号（:）组成，分隔三个表达式。它是 JavaScript 语言唯一一个需要三个运算子的运算符。如果第一个表达式的布尔值为"),v("code",[a._v("true")]),a._v("，则返回第二个表达式的值，否则返回第三个表达式的值。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("'t' ? 'hello' : 'world' // \"hello\"\n0 ? 'hello' : 'world' // \"world\"\n")])])]),v("p",[a._v("上面代码的"),v("code",[a._v("t")]),a._v("和"),v("code",[a._v("0")]),a._v("的布尔值分别为"),v("code",[a._v("true")]),a._v("和"),v("code",[a._v("false")]),a._v("，所以分别返回第二个和第三个表达式的值。")]),a._v(" "),v("p",[a._v("通常来说，三元条件表达式与"),v("code",[a._v("if...else")]),a._v("语句具有同样表达效果，前者可以表达的，后者也能表达。但是两者具有一个重大差别，"),v("code",[a._v("if...else")]),a._v("是语句，没有返回值；三元条件表达式是表达式，具有返回值。所以，在需要返回值的场合，只能使用三元条件表达式，而不能使用"),v("code",[a._v("if..else")]),a._v("。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("console.log(true ? 'T' : 'F');\n")])])]),v("p",[a._v("上面代码中，"),v("code",[a._v("console.log")]),a._v("方法的参数必须是一个表达式，这时就只能使用三元条件表达式。如果要用"),v("code",[a._v("if...else")]),a._v("语句，就必须改变整个代码写法了。")]),a._v(" "),v("h2",{attrs:{id:"二进制位运算符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二进制位运算符"}},[a._v("#")]),a._v(" 二进制位运算符")]),a._v(" "),v("h3",{attrs:{id:"概述-4"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#概述-4"}},[a._v("#")]),a._v(" 概述")]),a._v(" "),v("p",[a._v("二进制位运算符用于直接对二进制位进行计算，一共有7个。")]),a._v(" "),v("ul",[v("li",[v("strong",[a._v("二进制或运算符")]),a._v("（or）：符号为"),v("code",[a._v("|")]),a._v("，表示若两个二进制位都为"),v("code",[a._v("0")]),a._v("，则结果为"),v("code",[a._v("0")]),a._v("，否则为"),v("code",[a._v("1")]),a._v("。")]),a._v(" "),v("li",[v("strong",[a._v("二进制与运算符")]),a._v("（and）：符号为"),v("code",[a._v("&")]),a._v("，表示若两个二进制位都为1，则结果为1，否则为0。")]),a._v(" "),v("li",[v("strong",[a._v("二进制否运算符")]),a._v("（not）：符号为"),v("code",[a._v("~")]),a._v("，表示对一个二进制位取反。")]),a._v(" "),v("li",[v("strong",[a._v("异或运算符")]),a._v("（xor）：符号为"),v("code",[a._v("^")]),a._v("，表示若两个二进制位不相同，则结果为1，否则为0。")]),a._v(" "),v("li",[v("strong",[a._v("左移运算符")]),a._v("（left shift）：符号为"),v("code",[a._v("<<")]),a._v("，详见下文解释。")]),a._v(" "),v("li",[v("strong",[a._v("右移运算符")]),a._v("（right shift）：符号为"),v("code",[a._v(">>")]),a._v("，详见下文解释。")]),a._v(" "),v("li",[v("strong",[a._v("头部补零的右移运算符")]),a._v("（zero filled right shift）：符号为"),v("code",[a._v(">>>")]),a._v("，详见下文解释。")])]),a._v(" "),v("p",[a._v("这些位运算符直接处理每一个比特位（bit），所以是非常底层的运算，好处是速度极快，缺点是很不直观，许多场合不能使用它们，否则会使代码难以理解和查错。")]),a._v(" "),v("p",[a._v("有一点需要特别注意，位运算符只对整数起作用，如果一个运算子不是整数，会自动转为整数后再执行。另外，虽然在 JavaScript 内部，数值都是以64位浮点数的形式储存，但是做位运算的时候，是以32位带符号的整数进行运算的，并且返回值也是一个32位带符号的整数。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("i = i | 0;\n")])])]),v("p",[a._v("上面这行代码的意思，就是将"),v("code",[a._v("i")]),a._v("（不管是整数或小数）转为32位整数。")]),a._v(" "),v("p",[a._v("利用这个特性，可以写出一个函数，将任意数值转为32位整数。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("function toInt32(x) {\n  return x | 0;\n}\n")])])]),v("p",[a._v("上面这个函数将任意值与"),v("code",[a._v("0")]),a._v("进行一次或运算，这个位运算会自动将一个值转为32位整数。下面是这个函数的用法。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("toInt32(1.001) // 1\ntoInt32(1.999) // 1\ntoInt32(1) // 1\ntoInt32(-1) // -1\ntoInt32(Math.pow(2, 32) + 1) // 1\ntoInt32(Math.pow(2, 32) - 1) // -1\n")])])]),v("p",[a._v("上面代码中，"),v("code",[a._v("toInt32")]),a._v("可以将小数转为整数。对于一般的整数，返回值不会有任何变化。对于大于或等于2的32次方的整数，大于32位的数位都会被舍去。")]),a._v(" "),v("h3",{attrs:{id:"二进制或运算符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二进制或运算符"}},[a._v("#")]),a._v(" 二进制或运算符")]),a._v(" "),v("p",[a._v("二进制或运算符（"),v("code",[a._v("|")]),a._v("）逐位比较两个运算子，两个二进制位之中只要有一个为"),v("code",[a._v("1")]),a._v("，就返回"),v("code",[a._v("1")]),a._v("，否则返回"),v("code",[a._v("0")]),a._v("。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("0 | 3 // 3\n")])])]),v("p",[a._v("上面代码中，"),v("code",[a._v("0")]),a._v("和"),v("code",[a._v("3")]),a._v("的二进制形式分别是"),v("code",[a._v("00")]),a._v("和"),v("code",[a._v("11")]),a._v("，所以进行二进制或运算会得到"),v("code",[a._v("11")]),a._v("（即"),v("code",[a._v("3")]),a._v("）。")]),a._v(" "),v("p",[a._v("位运算只对整数有效，遇到小数时，会将小数部分舍去，只保留整数部分。所以，将一个小数与"),v("code",[a._v("0")]),a._v("进行二进制或运算，等同于对该数去除小数部分，即取整数位。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("2.9 | 0 // 2\n-2.9 | 0 // -2\n")])])]),v("p",[a._v("需要注意的是，这种取整方法不适用超过32位整数最大值"),v("code",[a._v("2147483647")]),a._v("的数。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("2147483649.4 | 0;\n// -2147483647\n")])])]),v("h3",{attrs:{id:"二进制与运算符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二进制与运算符"}},[a._v("#")]),a._v(" 二进制与运算符")]),a._v(" "),v("p",[a._v("二进制与运算符（"),v("code",[a._v("&")]),a._v("）的规则是逐位比较两个运算子，两个二进制位之中只要有一个位为"),v("code",[a._v("0")]),a._v("，就返回"),v("code",[a._v("0")]),a._v("，否则返回"),v("code",[a._v("1")]),a._v("。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("0 & 3 // 0\n")])])]),v("p",[a._v("上面代码中，0（二进制"),v("code",[a._v("00")]),a._v("）和3（二进制"),v("code",[a._v("11")]),a._v("）进行二进制与运算会得到"),v("code",[a._v("00")]),a._v("（即"),v("code",[a._v("0")]),a._v("）。")]),a._v(" "),v("h3",{attrs:{id:"二进制否运算符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二进制否运算符"}},[a._v("#")]),a._v(" 二进制否运算符")]),a._v(" "),v("p",[a._v("二进制否运算符（"),v("code",[a._v("~")]),a._v("）将每个二进制位都变为相反值（"),v("code",[a._v("0")]),a._v("变为"),v("code",[a._v("1")]),a._v("，"),v("code",[a._v("1")]),a._v("变为"),v("code",[a._v("0")]),a._v("）。它的返回结果有时比较难理解，因为涉及到计算机内部的数值表示机制。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("~ 3 // -4\n")])])]),v("p",[a._v("上面表达式对"),v("code",[a._v("3")]),a._v("进行二进制否运算，得到"),v("code",[a._v("-4")]),a._v("。之所以会有这样的结果，是因为位运算时，JavaScript 内部将所有的运算子都转为32位的二进制整数再进行运算。")]),a._v(" "),v("p",[v("code",[a._v("3")]),a._v("的32位整数形式是"),v("code",[a._v("00000000000000000000000000000011")]),a._v("，二进制否运算以后得到"),v("code",[a._v("11111111111111111111111111111100")]),a._v("。由于第一位（符号位）是1，所以这个数是一个负数。JavaScript 内部采用补码形式表示负数，即需要将这个数减去1，再取一次反，然后加上负号，才能得到这个负数对应的10进制值。这个数减去1等于"),v("code",[a._v("11111111111111111111111111111011")]),a._v("，再取一次反得到"),v("code",[a._v("00000000000000000000000000000100")]),a._v("，再加上负号就是"),v("code",[a._v("-4")]),a._v("。考虑到这样的过程比较麻烦，可以简单记忆成，一个数与自身的取反值相加，等于-1。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("~ -3 // 2\n")])])]),v("p",[a._v("上面表达式可以这样算，"),v("code",[a._v("-3")]),a._v("的取反值等于"),v("code",[a._v("-1")]),a._v("减去"),v("code",[a._v("-3")]),a._v("，结果为"),v("code",[a._v("2")]),a._v("。")]),a._v(" "),v("p",[a._v("对一个整数连续两次二进制否运算，得到它自身。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("~~3 // 3\n")])])]),v("p",[a._v("所有的位运算都只对整数有效。二进制否运算遇到小数时，也会将小数部分舍去，只保留整数部分。所以，对一个小数连续进行两次二进制否运算，能达到取整效果。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("~~2.9 // 2\n~~47.11 // 47\n~~1.9999 // 1\n~~3 // 3\n")])])]),v("p",[a._v("使用二进制否运算取整，是所有取整方法中最快的一种。")]),a._v(" "),v("p",[a._v("对字符串进行二进制否运算，JavaScript 引擎会先调用"),v("code",[a._v("Number")]),a._v("函数，将字符串转为数值。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("// 相当于~Number('011')\n~'011'  // -12\n\n// 相当于~Number('42 cats')\n~'42 cats' // -1\n\n// 相当于~Number('0xcafebabe')\n~'0xcafebabe' // 889275713\n\n// 相当于~Number('deadbeef')\n~'deadbeef' // -1\n")])])]),v("p",[v("code",[a._v("Number")]),a._v("函数将字符串转为数值的规则，参见《数据的类型转换》一章。")]),a._v(" "),v("p",[a._v("对于其他类型的值，二进制否运算也是先用"),v("code",[a._v("Number")]),a._v("转为数值，然后再进行处理。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("// 相当于 ~Number([])\n~[] // -1\n\n// 相当于 ~Number(NaN)\n~NaN // -1\n\n// 相当于 ~Number(null)\n~null // -1\n")])])]),v("h3",{attrs:{id:"异或运算符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#异或运算符"}},[a._v("#")]),a._v(" 异或运算符")]),a._v(" "),v("p",[a._v("异或运算（"),v("code",[a._v("^")]),a._v("）在两个二进制位不同时返回"),v("code",[a._v("1")]),a._v("，相同时返回"),v("code",[a._v("0")]),a._v("。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("0 ^ 3 // 3\n")])])]),v("p",[a._v("上面表达式中，"),v("code",[a._v("0")]),a._v("（二进制"),v("code",[a._v("00")]),a._v("）与"),v("code",[a._v("3")]),a._v("（二进制"),v("code",[a._v("11")]),a._v("）进行异或运算，它们每一个二进制位都不同，所以得到"),v("code",[a._v("11")]),a._v("（即"),v("code",[a._v("3")]),a._v("）。")]),a._v(" "),v("p",[a._v("“异或运算”有一个特殊运用，连续对两个数"),v("code",[a._v("a")]),a._v("和"),v("code",[a._v("b")]),a._v("进行三次异或运算，"),v("code",[a._v("a^=b; b^=a; a^=b;")]),a._v("，可以"),v("a",{attrs:{href:"https://en.wikipedia.org/wiki/XOR_swap_algorithm",target:"_blank",rel:"noopener noreferrer"}},[a._v("互换"),v("OutboundLink")],1),a._v("它们的值。这意味着，使用“异或运算”可以在不引入临时变量的前提下，互换两个变量的值。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var a = 10;\nvar b = 99;\n\na ^= b, b ^= a, a ^= b;\n\na // 99\nb // 10\n")])])]),v("p",[a._v("这是互换两个变量的值的最快方法。")]),a._v(" "),v("p",[a._v("异或运算也可以用来取整。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("12.9 ^ 0 // 12\n")])])]),v("h3",{attrs:{id:"左移运算符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#左移运算符"}},[a._v("#")]),a._v(" 左移运算符")]),a._v(" "),v("p",[a._v("左移运算符（"),v("code",[a._v("<<")]),a._v("）表示将一个数的二进制值向左移动指定的位数，尾部补"),v("code",[a._v("0")]),a._v("，即乘以"),v("code",[a._v("2")]),a._v("的指定次方。向左移动的时候，最高位的符号位是一起移动的。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("// 4 的二进制形式为100，\n// 左移一位为1000（即十进制的8）\n// 相当于乘以2的1次方\n4 << 1\n// 8\n\n-4 << 1\n// -8\n")])])]),v("p",[a._v("上面代码中，"),v("code",[a._v("-4")]),a._v("左移一位得到"),v("code",[a._v("-8")]),a._v("，是因为"),v("code",[a._v("-4")]),a._v("的二进制形式是"),v("code",[a._v("11111111111111111111111111111100")]),a._v("，左移一位后得到"),v("code",[a._v("11111111111111111111111111111000")]),a._v("，该数转为十进制（减去1后取反，再加上负号）即为"),v("code",[a._v("-8")]),a._v("。")]),a._v(" "),v("p",[a._v("如果左移0位，就相当于将该数值转为32位整数，等同于取整，对于正数和负数都有效。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("13.5 << 0\n// 13\n\n-13.5 << 0\n// -13\n")])])]),v("p",[a._v("左移运算符用于二进制数值非常方便。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var color = {r: 186, g: 218, b: 85};\n\n// RGB to HEX\n// (1 << 24)的作用为保证结果是6位数\nvar rgb2hex = function(r, g, b) {\n  return '#' + ((1 << 24) + (r << 16) + (g << 8) + b)\n    .toString(16) // 先转成十六进制，然后返回字符串\n    .substr(1);   // 去除字符串的最高位，返回后面六个字符串\n}\n\nrgb2hex(color.r, color.g, color.b)\n// \"#bada55\"\n")])])]),v("p",[a._v("上面代码使用左移运算符，将颜色的 RGB 值转为 HEX 值。")]),a._v(" "),v("h3",{attrs:{id:"右移运算符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#右移运算符"}},[a._v("#")]),a._v(" 右移运算符")]),a._v(" "),v("p",[a._v("右移运算符（"),v("code",[a._v(">>")]),a._v("）表示将一个数的二进制值向右移动指定的位数。如果是正数，头部全部补"),v("code",[a._v("0")]),a._v("；如果是负数，头部全部补"),v("code",[a._v("1")]),a._v("。右移运算符基本上相当于除以"),v("code",[a._v("2")]),a._v("的指定次方（最高位即符号位参与移动）。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("4 >> 1\n// 2\n/*\n// 因为4的二进制形式为 00000000000000000000000000000100，\n// 右移一位得到 00000000000000000000000000000010，\n// 即为十进制的2\n*/\n\n-4 >> 1\n// -2\n/*\n// 因为-4的二进制形式为 11111111111111111111111111111100，\n// 右移一位，头部补1，得到 11111111111111111111111111111110,\n// 即为十进制的-2\n*/\n")])])]),v("p",[a._v("右移运算可以模拟 2 的整除运算。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("5 >> 1\n// 2\n// 相当于 5 / 2 = 2\n\n21 >> 2\n// 5\n// 相当于 21 / 4 = 5\n\n21 >> 3\n// 2\n// 相当于 21 / 8 = 2\n\n21 >> 4\n// 1\n// 相当于 21 / 16 = 1\n")])])]),v("h3",{attrs:{id:"头部补零的右移运算符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#头部补零的右移运算符"}},[a._v("#")]),a._v(" 头部补零的右移运算符")]),a._v(" "),v("p",[a._v("头部补零的右移运算符（"),v("code",[a._v(">>>")]),a._v("）与右移运算符（"),v("code",[a._v(">>")]),a._v("）只有一个差别，就是一个数的二进制形式向右移动时，头部一律补零，而不考虑符号位。所以，该运算总是得到正值。对于正数，该运算的结果与右移运算符（"),v("code",[a._v(">>")]),a._v("）完全一致，区别主要在于负数。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("4 >>> 1\n// 2\n\n-4 >>> 1\n// 2147483646\n/*\n// 因为-4的二进制形式为11111111111111111111111111111100，\n// 带符号位的右移一位，得到01111111111111111111111111111110，\n// 即为十进制的2147483646。\n*/\n")])])]),v("p",[a._v("这个运算实际上将一个值转为32位无符号整数。")]),a._v(" "),v("p",[a._v("查看一个负整数在计算机内部的储存形式，最快的方法就是使用这个运算符。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("-1 >>> 0 // 4294967295\n")])])]),v("p",[a._v("上面代码表示，"),v("code",[a._v("-1")]),a._v("作为32位整数时，内部的储存形式使用无符号整数格式解读，值为 4294967295（即"),v("code",[a._v("(2^32)-1")]),a._v("，等于"),v("code",[a._v("11111111111111111111111111111111")]),a._v("）。")]),a._v(" "),v("h3",{attrs:{id:"开关作用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#开关作用"}},[a._v("#")]),a._v(" 开关作用")]),a._v(" "),v("p",[a._v("位运算符可以用作设置对象属性的开关。")]),a._v(" "),v("p",[a._v("假定某个对象有四个开关，每个开关都是一个变量。那么，可以设置一个四位的二进制数，它的每个位对应一个开关。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var FLAG_A = 1; // 0001\nvar FLAG_B = 2; // 0010\nvar FLAG_C = 4; // 0100\nvar FLAG_D = 8; // 1000\n")])])]),v("p",[a._v("上面代码设置 A、B、C、D 四个开关，每个开关分别占有一个二进制位。")]),a._v(" "),v("p",[a._v("然后，就可以用二进制与运算，检查当前设置是否打开了指定开关。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var flags = 5; // 二进制的0101\n\nif (flags & FLAG_C) {\n  // ...\n}\n// 0101 & 0100 => 0100 => true\n")])])]),v("p",[a._v("上面代码检验是否打开了开关"),v("code",[a._v("C")]),a._v("。如果打开，会返回"),v("code",[a._v("true")]),a._v("，否则返回"),v("code",[a._v("false")]),a._v("。")]),a._v(" "),v("p",[a._v("现在假设需要打开"),v("code",[a._v("A")]),a._v("、"),v("code",[a._v("B")]),a._v("、"),v("code",[a._v("D")]),a._v("三个开关，我们可以构造一个掩码变量。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var mask = FLAG_A | FLAG_B | FLAG_D;\n// 0001 | 0010 | 1000 => 1011\n")])])]),v("p",[a._v("上面代码对"),v("code",[a._v("A")]),a._v("、"),v("code",[a._v("B")]),a._v("、"),v("code",[a._v("D")]),a._v("三个变量进行二进制或运算，得到掩码值为二进制的"),v("code",[a._v("1011")]),a._v("。")]),a._v(" "),v("p",[a._v("有了掩码，二进制或运算可以确保打开指定的开关。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("flags = flags | mask;\n")])])]),v("p",[a._v("上面代码中，计算后得到的"),v("code",[a._v("flags")]),a._v("变量，代表三个开关的二进制位都打开了。")]),a._v(" "),v("p",[a._v("二进制与运算可以将当前设置中凡是与开关设置不一样的项，全部关闭。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("flags = flags & mask;\n")])])]),v("p",[a._v("异或运算可以切换（toggle）当前设置，即第一次执行可以得到当前设置的相反值，再执行一次又得到原来的值。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("flags = flags ^ mask;\n")])])]),v("p",[a._v("二进制否运算可以翻转当前设置，即原设置为"),v("code",[a._v("0")]),a._v("，运算后变为"),v("code",[a._v("1")]),a._v("；原设置为"),v("code",[a._v("1")]),a._v("，运算后变为"),v("code",[a._v("0")]),a._v("。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("flags = ~flags;\n")])])]),v("h3",{attrs:{id:"参考链接"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#参考链接"}},[a._v("#")]),a._v(" 参考链接")]),a._v(" "),v("ul",[v("li",[a._v("Michal Budzynski, "),v("a",{attrs:{href:"https://michalbe.blogspot.co.uk/2013/03/javascript-less-known-parts-bitwise.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("JavaScript: The less known parts. Bitwise Operators"),v("OutboundLink")],1)]),a._v(" "),v("li",[a._v("Axel Rauschmayer, "),v("a",{attrs:{href:"http://www.2ality.com/2013/06/basic-javascript.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("Basic JavaScript for the impatient programmer"),v("OutboundLink")],1)]),a._v(" "),v("li",[a._v("Mozilla Developer Network, "),v("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators",target:"_blank",rel:"noopener noreferrer"}},[a._v("Bitwise Operators"),v("OutboundLink")],1)])]),a._v(" "),v("h2",{attrs:{id:"其他运算符和运算顺序"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#其他运算符和运算顺序"}},[a._v("#")]),a._v(" 其他运算符和运算顺序")]),a._v(" "),v("h3",{attrs:{id:"void-运算符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#void-运算符"}},[a._v("#")]),a._v(" void 运算符")]),a._v(" "),v("p",[v("code",[a._v("void")]),a._v("运算符的作用是执行一个表达式，然后不返回任何值，或者说返回"),v("code",[a._v("undefined")]),a._v("。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("void 0 // undefined\nvoid(0) // undefined\n")])])]),v("p",[a._v("上面是"),v("code",[a._v("void")]),a._v("运算符的两种写法，都正确。建议采用后一种形式，即总是使用圆括号。因为"),v("code",[a._v("void")]),a._v("运算符的优先性很高，如果不使用括号，容易造成错误的结果。比如，"),v("code",[a._v("void 4 + 7")]),a._v("实际上等同于"),v("code",[a._v("(void 4) + 7")]),a._v("。")]),a._v(" "),v("p",[a._v("下面是"),v("code",[a._v("void")]),a._v("运算符的一个例子。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var x = 3;\nvoid (x = 5) //undefined\nx // 5\n")])])]),v("p",[a._v("这个运算符的主要用途是浏览器的书签工具（Bookmarklet），以及在超级链接中插入代码防止网页跳转。")]),a._v(" "),v("p",[a._v("请看下面的代码。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v('<script>\nfunction f() {\n  console.log(\'Hello World\');\n}\n<\/script>\n<a href="http://example.com" onclick="f(); return false;">点击</a>\n')])])]),v("p",[a._v("上面代码中，点击链接后，会先执行"),v("code",[a._v("onclick")]),a._v("的代码，由于"),v("code",[a._v("onclick")]),a._v("返回"),v("code",[a._v("false")]),a._v("，所以浏览器不会跳转到 example.com。")]),a._v(" "),v("p",[v("code",[a._v("void")]),a._v("运算符可以取代上面的写法。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v('<a href="javascript: void(f())">文字</a>\n')])])]),v("p",[a._v("下面是一个更实际的例子，用户点击链接提交表单，但是不产生页面跳转。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v('<a href="javascript: void(document.form.submit())">\n  提交\n</a>\n')])])]),v("h3",{attrs:{id:"逗号运算符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#逗号运算符"}},[a._v("#")]),a._v(" 逗号运算符")]),a._v(" "),v("p",[a._v("逗号运算符用于对两个表达式求值，并返回后一个表达式的值。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("'a', 'b' // \"b\"\n\nvar x = 0;\nvar y = (x++, 10);\nx // 1\ny // 10\n")])])]),v("p",[a._v("上面代码中，逗号运算符返回后一个表达式的值。")]),a._v(" "),v("p",[a._v("逗号运算符的一个用途是，在返回一个值之前，进行一些辅助操作。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var value = (console.log('Hi!'), true);\n// Hi!\n\nvalue // true\n")])])]),v("p",[a._v("上面代码中，先执行逗号之前的操作，然后返回逗号后面的值。")]),a._v(" "),v("h3",{attrs:{id:"运算顺序"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#运算顺序"}},[a._v("#")]),a._v(" 运算顺序")]),a._v(" "),v("h4",{attrs:{id:"优先级"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#优先级"}},[a._v("#")]),a._v(" 优先级")]),a._v(" "),v("p",[a._v("JavaScript 各种运算符的优先级别（Operator Precedence）是不一样的。优先级高的运算符先执行，优先级低的运算符后执行。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("4 + 5 * 6 // 34\n")])])]),v("p",[a._v("上面的代码中，乘法运算符（"),v("code",[a._v("*")]),a._v("）的优先性高于加法运算符（"),v("code",[a._v("+")]),a._v("），所以先执行乘法，再执行加法，相当于下面这样。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("4 + (5 * 6) // 34\n")])])]),v("p",[a._v("如果多个运算符混写在一起，常常会导致令人困惑的代码。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var x = 1;\nvar arr = [];\n\nvar y = arr.length <= 0 || arr[0] === undefined ? x : arr[0];\n")])])]),v("p",[a._v("上面代码中，变量"),v("code",[a._v("y")]),a._v("的值就很难看出来，因为这个表达式涉及5个运算符，到底谁的优先级最高，实在不容易记住。")]),a._v(" "),v("p",[a._v("根据语言规格，这五个运算符的优先级从高到低依次为：小于等于（"),v("code",[a._v("<=")]),a._v(")、严格相等（"),v("code",[a._v("===")]),a._v("）、或（"),v("code",[a._v("||")]),a._v("）、三元（"),v("code",[a._v("?:")]),a._v("）、等号（"),v("code",[a._v("=")]),a._v("）。因此上面的表达式，实际的运算顺序如下。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var y = ((arr.length <= 0) || (arr[0] === undefined)) ? x : arr[0];\n")])])]),v("p",[a._v("记住所有运算符的优先级，是非常难的，也是没有必要的。")]),a._v(" "),v("h4",{attrs:{id:"圆括号的作用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#圆括号的作用"}},[a._v("#")]),a._v(" 圆括号的作用")]),a._v(" "),v("p",[a._v("圆括号（"),v("code",[a._v("()")]),a._v("）可以用来提高运算的优先级，因为它的优先级是最高的，即圆括号中的表达式会第一个运算。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("(4 + 5) * 6 // 54\n")])])]),v("p",[a._v("上面代码中，由于使用了圆括号，加法会先于乘法执行。")]),a._v(" "),v("p",[a._v("运算符的优先级别十分繁杂，且都是硬性规定，因此建议总是使用圆括号，保证运算顺序清晰可读，这对代码的维护和除错至关重要。")]),a._v(" "),v("p",[a._v("顺便说一下，圆括号不是运算符，而是一种语法结构。它一共有两种用法：一种是把表达式放在圆括号之中，提升运算的优先级；另一种是跟在函数的后面，作用是调用函数。")]),a._v(" "),v("p",[a._v("注意，因为圆括号不是运算符，所以不具有求值作用，只改变运算的优先级。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var x = 1;\n(x) = 2;\n")])])]),v("p",[a._v("上面代码的第二行，如果圆括号具有求值作用，那么就会变成"),v("code",[a._v("1 = 2")]),a._v("，这是会报错了。但是，上面的代码可以运行，这验证了圆括号只改变优先级，不会求值。")]),a._v(" "),v("p",[a._v("这也意味着，如果整个表达式都放在圆括号之中，那么不会有任何效果。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("(expression)\n// 等同于\nexpression\n")])])]),v("p",[a._v("函数放在圆括号中，会返回函数本身。如果圆括号紧跟在函数的后面，就表示调用函数。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("function f() {\n  return 1;\n}\n\n(f) // function f(){return 1;}\nf() // 1\n")])])]),v("p",[a._v("上面代码中，函数放在圆括号之中会返回函数本身，圆括号跟在函数后面则是调用函数。")]),a._v(" "),v("p",[a._v("圆括号之中，只能放置表达式，如果将语句放在圆括号之中，就会报错。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("(var a = 1)\n// SyntaxError: Unexpected token var\n")])])]),v("h4",{attrs:{id:"左结合与右结合"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#左结合与右结合"}},[a._v("#")]),a._v(" 左结合与右结合")]),a._v(" "),v("p",[a._v("对于优先级别相同的运算符，同时出现的时候，就会有计算顺序的问题。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("a OP b OP c\n")])])]),v("p",[a._v("上面代码中，"),v("code",[a._v("OP")]),a._v("表示运算符。它可以有两种解释方式。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("// 方式一\n(a OP b) OP c\n\n// 方式二\na OP (b OP c)\n")])])]),v("p",[a._v("上面的两种方式，得到的计算结果往往是不一样的。方式一是将左侧两个运算数结合在一起，采用这种解释方式的运算符，称为“左结合”（left-to-right associativity）运算符；方式二是将右侧两个运算数结合在一起，这样的运算符称为“右结合”运算符（right-to-left associativity）。")]),a._v(" "),v("p",[a._v("JavaScript 语言的大多数运算符是“左结合”，请看下面加法运算符的例子。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("x + y + z\n\n// 引擎解释如下\n(x + y) + z\n")])])]),v("p",[a._v("上面代码中，"),v("code",[a._v("x")]),a._v("与"),v("code",[a._v("y")]),a._v("结合在一起，它们的预算结果再与"),v("code",[a._v("z")]),a._v("进行运算。")]),a._v(" "),v("p",[a._v("少数运算符是“右结合”，其中最主要的是赋值运算符（"),v("code",[a._v("=")]),a._v("）和三元条件运算符（"),v("code",[a._v("?:")]),a._v("）。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("w = x = y = z;\nq = a ? b : c ? d : e ? f : g;\n")])])]),v("p",[a._v("上面代码的解释方式如下。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("w = (x = (y = z));\nq = a ? b : (c ? d : (e ? f : g));\n")])])]),v("p",[a._v("上面的两行代码，都是右侧的运算数结合在一起。")]),a._v(" "),v("p",[a._v("另外，指数运算符（"),v("code",[a._v("**")]),a._v("）也是右结合。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("2 ** 3 ** 2\n// 相当于 2 ** (3 ** 2)\n// 512\n")])])])])}),[],!1,null,null,null);e.default=_.exports}}]);